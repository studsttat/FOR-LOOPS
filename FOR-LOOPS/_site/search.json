[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of for loops from various programming languages",
    "section": "",
    "text": "(Notice that some of the programming languages are not used in this example. I only used those languages that can be used in computing and listed in knitr.)\nIn this activity, I show you the programming languages that can be used in computing with the use of for loops.\nNote that not all the programming languages are listed in this example because these are all the programming languages I know that can be exported into R.\nHere are the list of languages will be used in this activity:\nThey are all high level languages (or I should say some of them are close to high level languages) and share similarities. I only used those languages that can be both used in computing and listed in knitr."
  },
  {
    "objectID": "index.html#approximating-pi",
    "href": "index.html#approximating-pi",
    "title": "Comparison of for loops from various programming languages",
    "section": "Approximating \\(\\pi\\)",
    "text": "Approximating \\(\\pi\\)\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\nIf your purpose is a language for computing within R, C is maybe easier than C++ but in order this to be working and exportable, the result of the computation is needed to store the memory address, a.k.a. the pointers.\n\n#include &lt;stdio.h&gt;\n\nvoid pi_approx_c(int *n, double *result) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 1; i &lt;= *n; i++) {\n    pi_4 += sign / (2 * i - 1);\n    sign *= -1;\n  }\n  \n  *result = 4 * pi_4;\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c3fc471d3b90.c -o c3fc471d3b90.o\ngcc -shared -s -static-libgcc -o c3fc471d3b90.dll tmp.def c3fc471d3b90.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nIn order to natively call the C code into R, use .C and then extract the result via $res.\n\npi_approx_c &lt;- function(n) {\n  res &lt;- .C(\"pi_approx_c\", as.integer(n), res=numeric(1))$res\n  return(res)\n}\n\npi_approx_c(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, the C++ code is way similar to the C code except, we don’t need to use pointers in order the result to store its memory address. Like I said, using Rcpp, the C++ code is so easy to be exported, as long as its error-free.\nAfter compiling, you don’t need to call it and the pi_approx_cpp will be saved into R Global Environment directly.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble pi_approx_cpp(int n) {\n  double pi_4 = 0;\n  double sign = 1;\n  \n  for (int i = 1; i &lt;= n; i++) {\n    pi_4 += sign / (2 * i - 1);\n    sign *= -1;\n  }\n  \n  return 4 * pi_4;\n}\n\n/***R\npi_approx_cpp(1e5)\n*/\n\n\n\nAs you can see, we only write few codes, unlike in C/C++, to approximate the \\(\\pi\\)\n\nfunction pi_approx_jl(n)\n    pi_4 = 0.0\n    sign = 1.0\n    for i in 1:n\n        pi_4 += sign / (2*i - 1)\n        sign *= -1\n    end\n    return 4 * pi_4\nend\n\npi_approx_jl (generic function with 1 method)\n\n\nWith JuliaCall, you can call the Julia function into R via julia_eval. But there are few other ways to call it, but I found julia_eval more convenient.\n\npi_approx_jl &lt;- JuliaCall::julia_eval(\"pi_approx_jl\")\npi_approx_jl(1e5)\n\n[1] 3.141583\n\n\n\n\nHere, we use the extendr API to compile the Rust code into R, just like we did with Rcpp to compile the C++ code into R.\n\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn pi_approx_rs(n: i32) -&gt; f64 {\n    let mut pi_4 = 0.0;\n    let mut sign = 1.0;\n    \n    for i in 1..=n {\n        pi_4 += sign / (2 * i - 1) as f64;\n        sign *= -1.0;\n    }\n    \n    4.0 * pi_4\n}\n\nAfter compiling, just like C++, the pi_approx_rs function in Rust will be saved into R Global Environment directly.\n\npi_approx_rs(1e5)\n\n[1] 3.141583\n\n\n\n\nMaybe FORTRAN is fast, but the solution is more boilerplate, although for me it is more readable compared to C/C++. Just like C, we need the result to be store in memory address.\nIf you use old FORTRAN version, you might need to CAPITALIZE the FORTRAN program. But we use the ’95 version of FORTRAN so we don’t need to CAPITALIZE the program.\n\nsubroutine pi_approx(n, result)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: result\n    integer :: i\n    real(8) :: pi_4, sign\n    \n    pi_4 = 0.0\n    sign = 1.0\n    \n    do i = 1, n\n        pi_4 = pi_4 + sign / (2 * i - 1)\n        sign = sign * (-1.0)\n    end do\n    \n    result = 4 * pi_4\nend subroutine pi_approx\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f953fc44047445e.f95 -o f953fc44047445e.o\ngcc -shared -s -static-libgcc -o f953fc44047445e.dll tmp.def f953fc44047445e.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\nJust like C, but instead, in order to natively call the FORTRAN code into R, use .Fortran and then extract the result via $result.\n\npi_approx_fortran &lt;- function(n) {\n  result &lt;- .Fortran(\"pi_approx\", as.integer(n), result=double(1))$result\n  return(result)\n}\n\npi_approx_fortran(1e5)\n\n[1] 3.141583\n\n\n\n\nR is so close to be functional programming and to be Domain Specific Language (or DSL). It is so functional, you need to use &lt;- function() to define a function and I sometimes agree that this is ugly but hey it works! This is just my opinion.\nR is already a default language in RStudio, so the function we define is already callable in R Global Environment.\n\npi_approx_r &lt;- function(n) {\n  pi_4 &lt;- 0\n  sign &lt;- 1\n  \n  for (i in 1:n) {\n    pi_4 &lt;- pi_4 + sign / (2*i - 1)\n    sign &lt;- sign * -1\n  }\n  \n  return(4 * pi_4)\n}\n\npi_approx_r(1e5)\n\n[1] 3.141583\n\n\n\n\nR and Python has so much similarities, except Python is more onto general purpose language.\n\ndef pi_approx_py(n):\n    n = int(n)\n    pi_4 = 0\n    sign = 1\n    \n    for i in range(1, n + 1):\n        pi_4 += sign / (2 * i - 1)\n        sign *= -1\n    return pi_4 * 4\n\nThe defined function in Python is also callable. Using py module in reticulate package, you can easily interact with any Python objects in Python module.\n\npi_approx_py &lt;- reticulate::py$pi_approx_py\npi_approx_py(1e5)\n\n[1] 3.141583\n\n\n\n\n\npi_approx_bm &lt;- bench::mark(\n  C = pi_approx_c(1e8),\n  Cpp = pi_approx_cpp(1e8),\n  Julia = pi_approx_jl(1e8),\n  Rust = pi_approx_rs(1e8),\n  FORTRAN = pi_approx_fortran(1e8),\n  R = pi_approx_r(1e8),\n  Python = pi_approx_py(1e8),\n  check = F\n)\npi_approx_bm\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C          145.07ms 160.33ms    6.22     16.46KB        0\n2 Cpp        165.12ms 170.51ms    5.88      7.67KB        0\n3 Julia      390.62ms 392.64ms    2.55      5.73KB        0\n4 Rust          1.38s    1.38s    0.726      4.8KB        0\n5 FORTRAN    155.23ms  157.4ms    6.22     16.46KB        0\n6 R            11.27s   11.27s    0.0887        0B        0\n7 Python       20.25s   20.25s    0.0494    4.98KB        0\n\npi_approx_bm |&gt; plot()\n\nLoading required namespace: tidyr\n\n\n\n\n\n\n\n\n\nFrom this result, we can say that the C++ is the fastest language among the 7 languages I selected for computing in using for loops, following with C and FORTRAN."
  },
  {
    "objectID": "index.html#recursive-fibonacci-sequence",
    "href": "index.html#recursive-fibonacci-sequence",
    "title": "Comparison of for loops from various programming languages",
    "section": "Recursive Fibonacci Sequence",
    "text": "Recursive Fibonacci Sequence\n\nCC++JuliaRustFORTRANRPythonBenchmarks\n\n\n\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt;\n\nvoid fib_c(int *n, int *seq) {\n    seq[0] = 0;\n    if (*n &gt; 0) {\n        seq[1] = 1;\n        for (int i = 2; i &lt;= *n; ++i) {\n            seq[i] = seq[i - 1] + seq[i - 2];\n        }\n    }\n}\n\ngcc  -I\"D:/R GUI/R-4.3.3/R-4.3.3/include\" -DNDEBUG     -I\"C:/rtools43/x86_64-w64-mingw32.static.posix/include\"     -O2 -Wall  -mfpmath=sse -msse2 -mstackrealign  -c c3fc46096143.c -o c3fc46096143.o\ngcc -shared -s -static-libgcc -o c3fc46096143.dll tmp.def c3fc46096143.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_c &lt;- function(n) {\n  seq &lt;- integer(n + 1)\n  .C(\"fib_c\", n = as.integer(n), seq = as.integer(seq))$seq\n}\nfib_c(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector fib_cpp(int n){\n  IntegerVector fibSequence(n + 1);\n  fibSequence[0] = 0;\n  if (n &gt; 1) {\n    fibSequence[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n  }\n  return fibSequence;\n  \n}\n\n\n/***R\nfib_cpp(10)\n*/\n\n\n\n\nfunction fib_jl(n::Int)\n  fib = Int[]\n  push!(fib, 0)  \n  push!(fib, 1)  \n  \n  \n  for i in 3:n\n      push!(fib, fib[i - 1] + fib[i - 2])  \n  end\n  \n  return fib\nend\n\nfib_jl (generic function with 1 method)\n\n\n\nfib_jl &lt;- JuliaCall::julia_eval(\"fib_jl\")\nfib_jl(10L)\n\n [1]  0  1  1  2  3  5  8 13 21 34\n\n\n\n\n\nuse extendr_api::prelude::*;\nuse std::collections::HashMap;\n\nfn fibonacci(n: i32, memo: &mut HashMap&lt;i32, i32&gt;) -&gt; i32 {\n    if let Some(&result) = memo.get(&n) {\n        return result;\n    }\n\n    let result = if n &lt;= 1 {\n        n\n    } else {\n        fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n    };\n\n    memo.insert(n, result);\n    result\n}\n\n#[extendr]\nfn fib_rs(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut sequence = vec![];\n    let mut memo = HashMap::new();\n\n    for i in 0..n + 1 {\n        sequence.push(fibonacci(i, &mut memo));\n    }\n\n    sequence\n}\n\n\nfib_rs(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nsubroutine fib_f(n, fib)\n    integer, intent(in) :: n\n    integer, intent(out) :: fib(n)\n    integer :: i\n    \n    fib(1) = 0\n    fib(2) = 1\n\n    do i = 3, n + 1\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\nend subroutine fib_f\n\ngfortran      -O2  -mfpmath=sse -msse2 -mstackrealign  -c  f953fc44ab66452.f95 -o f953fc44ab66452.o\ngcc -shared -s -static-libgcc -o f953fc44ab66452.dll tmp.def f953fc44ab66452.o -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib/x64 -LC:/rtools43/x86_64-w64-mingw32.static.posix/lib -lgfortran -lm -lquadmath -LD:/R GUI/R-4.3.3/R-4.3.3/bin/x64 -lR\n\n\n\nfib_fortran &lt;- function(n) {\n  n &lt;- n + 1\n  .Fortran(\"fib_f\", as.integer(n), fib = integer(n))$fib\n}\nfib_fortran(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nfib_r &lt;- function(n) {\n  fib &lt;- integer(n + 1)\n  fib[1] &lt;- 0\n  fib[2] &lt;- 1\n  for (i in 3:(n+1)) {\n    fib[i] &lt;- fib[i - 1] + fib[i - 2]\n  }\n  return(fib)\n}\n\nfib_r(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\ndef fib_p(n):\n    n = int(n)\n    fib_seq = [0, 1]\n    for i in range(2, n + 1):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\n\nfib_py &lt;- reticulate::py$fib_p\nfib_py(10)\n\n [1]  0  1  1  2  3  5  8 13 21 34 55\n\n\n\n\n\nbench::mark(\n  C = fib_c(40),\n  Cpp = fib_cpp(40),\n  Julia = fib_jl(41L),\n  Rust = fib_rs(40),\n  FORTRAN = fib_fortran(40),\n  R = fib_r(40),\n  Python = fib_py(40),\n  check = F\n)\n\n# A tibble: 7 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 C             2.6µs    2.8µs   237323.   19.23KB    23.7 \n2 Cpp           1.5µs    1.8µs   302155.    6.84KB     0   \n3 Julia         9.7µs   10.2µs    88843.    4.89KB     0   \n4 Rust           69µs   70.5µs    13760.    5.02KB     0   \n5 FORTRAN       2.7µs      3µs   291408.   17.73KB     0   \n6 R             7.4µs    8.1µs   114432.      592B     0   \n7 Python       51.4µs   54.5µs    16583.     5.2KB     4.17"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]